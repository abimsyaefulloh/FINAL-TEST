# simpan sebagai: deploy-be-dumbmerch-remote.yml
- hosts: gatewayserver
  become: true
  gather_facts: true

  vars:
    # --- App & repo ---
    repo_url: "https://github.com/abimsyaefulloh/be-dumbmerch.git"
    repo_version: "main"
    repo_dest: "/opt/be-dumbmerch"

    image_name: "be-dumbmerch"
    container_name: "be-dumbmerch"

    host_port: 5000
    container_port: 5000

    # --- Database ---
    db_service: "db"
    db_container: "dumbmerch-db"
    db_image: "postgres:14"
    db_host_port: 5432
    db_name: "dumbmerch"
    db_user: "abim"
    db_password: "abim123"

    # --- Remote access controls ---
    # Bind port Postgres ke interface mana:
    #   - "0.0.0.0"  => semua interface (setara "5432:5432")
    #   - "192.168.1.10" => hanya di IP privat itu
    #   - "127.0.0.1" => lokal host saja (TIDAK remote)
    db_publish_binding: "0.0.0.0"
    db_ports_mapping: "{{ (db_publish_binding == '0.0.0.0') | ternary(db_host_port ~ ':5432', db_publish_binding ~ ':' ~ db_host_port ~ ':5432') }}"

    # CIDR/IP yang diizinkan akses Postgres (pg_hba.conf)
    remote_allowed_cidrs:
      - "192.168.1.0/24"
      # - "10.10.10.20/32"   # contoh satu host saja

    # --- Deploy behavior ---
    recreate_stack: true # true: compose down dulu, lalu up (recreate container)
    wipe_db_data: false # true: HAPUS volume db_data (reset database)
    docker_arch: "{{ 'arm64' if ansible_machine in ['aarch64','arm64'] else 'amd64' }}"
    deploy_user: "{{ ansible_user | default('ubuntu') }}"

    # --- Optional firewall (UFW). Default tidak diubah supaya aman. ---
    manage_firewall: false
    enable_ufw: false

    # Healthcheck path backend (pakai endpoint yang ada)
    backend_health_path: "/api/v1/users"

  pre_tasks:
    - name: Remove old Docker packages (prevent conflict)
      apt:
        name:
          - docker.io
          - docker-doc
          - docker-compose
          - podman-docker
          - containerd
          - runc
        state: absent
        purge: yes
      ignore_errors: true

    - name: Install prerequisites
      apt:
        name:
          - ca-certificates
          - curl
          - gnupg
          - lsb-release
          - git
        state: present
        update_cache: true

    - name: Add Docker GPG key
      apt_key:
        url: https://download.docker.com/linux/ubuntu/gpg
        state: present

    - name: Add Docker apt repository
      apt_repository:
        repo: "deb [arch={{ docker_arch }}] https://download.docker.com/linux/ubuntu {{ ansible_distribution_release }} stable"
        state: present
        filename: docker

    - name: Install Docker engine + tools
      apt:
        name:
          - docker-ce
          - docker-ce-cli
          - containerd.io
          - docker-buildx-plugin
          - docker-compose-plugin
          - python3-docker
        state: present
        update_cache: true

    - name: Ensure Docker running & enabled
      systemd:
        name: docker
        state: started
        enabled: true

    - name: Add current SSH user to docker group
      user:
        name: "{{ deploy_user }}"
        groups: docker
        append: true

  tasks:
    - name: Ensure app directory exists
      file:
        path: "{{ repo_dest }}"
        state: directory
        mode: "0755"

    - name: Clone backend repository
      git:
        repo: "{{ repo_url }}"
        dest: "{{ repo_dest }}"
        version: "{{ repo_version }}"
        force: true

    - name: Generate Dockerfile for backend (with pg_isready client)
      copy:
        dest: "{{ repo_dest }}/Dockerfile"
        content: |
          FROM golang:1.20-alpine

          WORKDIR /app
          RUN apk add --no-cache git postgresql-client

          COPY go.mod go.sum ./
          RUN go mod download

          COPY . .
          RUN go build -o main .

          EXPOSE 5000
          CMD ["./main"]

    - name: Generate docker-compose.yml (remote-access ready)
      copy:
        dest: "{{ repo_dest }}/docker-compose.yml"
        content: |
          services:
            backend:
              build: .
              container_name: {{ container_name }}
              environment:
                PORT: "5000"
                DB_HOST: {{ db_service }}
                DB_PORT: "5432"
                DB_USER: {{ db_user }}
                DB_PASSWORD: {{ db_password }}
                DB_NAME: {{ db_name }}
              ports:
                - "{{ host_port }}:{{ container_port }}"
              depends_on:
                {{ db_service }}:
                  condition: service_healthy
              # Tunggu DB siap sebelum jalankan app
              command: >
                sh -c 'until pg_isready -h {{ db_service }} -p 5432 -U {{ db_user }} -d {{ db_name }};
                do echo "waiting for postgres..."; sleep 2; done; ./main'
              restart: always
              healthcheck:
                test: ["CMD-SHELL", "wget -qO- http://127.0.0.1:{{ container_port }}{{ backend_health_path }} > /dev/null 2>&1 || exit 1"]
                interval: 10s
                timeout: 5s
                retries: 12
                start_period: 20s

            {{ db_service }}:
              image: {{ db_image }}
              container_name: {{ db_container }}
              restart: always
              environment:
                POSTGRES_USER: {{ db_user }}
                POSTGRES_PASSWORD: {{ db_password }}
                POSTGRES_DB: {{ db_name }}
              volumes:
                - db_data:/var/lib/postgresql/data
              # ⚠️ Port dibuka agar bisa diakses server lain
              ports:
                - "{{ db_ports_mapping }}"
              healthcheck:
                test: ["CMD-SHELL", "pg_isready -U {{ db_user }} -d {{ db_name }}"]
                interval: 10s
                timeout: 5s
                retries: 20
                start_period: 40s

          volumes:
            db_data:

    # --- Compose down/up ---
    - name: Docker compose DOWN (keep volume) — when recreate_stack and not wiping data
      command: docker compose down --remove-orphans
      args:
        chdir: "{{ repo_dest }}"
      when:
        - recreate_stack
        - not wipe_db_data

    - name: Docker compose DOWN with volume (WIPE DB DATA) — when requested
      command: docker compose down -v --remove-orphans
      args:
        chdir: "{{ repo_dest }}"
      when:
        - recreate_stack
        - wipe_db_data

    - name: Docker compose UP (build & force recreate)
      command: docker compose up -d --build --force-recreate --remove-orphans
      args:
        chdir: "{{ repo_dest }}"

    # --- Tunggu DB benar-benar ready (baru edit pg_hba.conf) ---
    - name: Wait for PostgreSQL to be ready
      command: docker compose exec -T {{ db_service }} pg_isready -U {{ db_user }} -d {{ db_name }}
      args:
        chdir: "{{ repo_dest }}"
      register: pg_ready
      retries: 20
      delay: 3
      until: pg_ready.rc == 0

    # --- Tambah rule pg_hba.conf untuk CIDR/IP yang diizinkan ---
    - name: Ensure pg_hba.conf has remote allow rules
      shell: |
        docker compose exec -T {{ db_service }} bash -lc "grep -qE '^host\\s+all\\s+all\\s+{{ item | regex_escape() }}\\s+md5$' /var/lib/postgresql/data/pg_hba.conf || echo 'host all all {{ item }} md5' >> /var/lib/postgresql/data/pg_hba.conf"
      args:
        chdir: "{{ repo_dest }}"
      loop: "{{ remote_allowed_cidrs }}"

    - name: Reload PostgreSQL config after pg_hba changes
      command: docker compose exec -T {{ db_service }} psql -U {{ db_user }} -d {{ db_name }} -c "SELECT pg_reload_conf()"
      args:
        chdir: "{{ repo_dest }}"

    # --- (Opsional) UFW firewall rules ---
    - name: Install UFW (optional)
      apt:
        name: ufw
        state: present
        update_cache: true
      when: manage_firewall

    - name: Allow Postgres from allowed CIDRs (UFW)
      command: ufw allow from {{ item }} to any port {{ db_host_port }} proto tcp
      loop: "{{ remote_allowed_cidrs }}"
      when: manage_firewall

    - name: (Optional) Enable UFW — CAUTION can lock you out
      command: ufw --force enable
      when: manage_firewall and enable_ufw

    # --- Output ---
    - name: Print access info
      debug:
        msg:
          - "Backend API: http://{{ ansible_default_ipv4.address | default(inventory_hostname) }}:{{ host_port }}"
          - "Postgres DSN (remote): postgresql://{{ db_user }}:{{ db_password }}@{{ ansible_default_ipv4.address | default(inventory_hostname) }}:{{ db_host_port }}/{{ db_name }}"
          - "Allowed DB CIDRs: {{ remote_allowed_cidrs | join(', ') }}"
